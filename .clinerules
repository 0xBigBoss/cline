# Cline Extension Architecture & Development Guide

## Project Overview

Cline is a VSCode extension that provides AI assistance through a combination of a core extension backend and a React-based webview frontend. The extension is built with TypeScript and follows a modular architecture pattern.

## Core Extension Architecture

### Operation Modes

1. **ACT Mode**
   - Default execution mode
   - Handles tool usage and task execution
   - Manages file operations and system commands
   - Coordinates with MCP servers

2. **PLAN Mode**
   - Planning and discussion mode
   - Gathers requirements and context
   - Creates implementation strategies
   - Validates approaches with user

### Task Execution Lifecycle

1. **Task Initialization**
   - Task creation and ID assignment
   - Context gathering
   - Environment setup
   - State initialization

2. **Message Processing**
   - Message parsing and validation
   - Tool use coordination
   - Response streaming
   - State updates

3. **Task Completion**
   - Result verification
   - State cleanup
   - Resource release
   - History updates

### Message Handling

1. **Streaming Implementation**
   - Chunk processing
   - Partial updates
   - Progress indication
   - Error recovery

2. **Message Types**
   - System messages
   - User messages
   - Assistant messages
   - Tool responses

### Workspace Integration

1. **File Watching**
   - Change detection
   - Event debouncing
   - Path filtering
   - Update notifications

2. **Environment Management**
   - Workspace state tracking
   - Terminal monitoring
   - File system access
   - Path resolution

### Key Components

1. **ClineProvider (src/core/webview/ClineProvider.ts)**
   - Main controller for the extension
   - Manages webview lifecycle
   - Handles state persistence
   - Coordinates between webview and extension
   - Manages task history and checkpoints

2. **Cline Class (src/core/Cline.ts)**
   - Core business logic
   - Handles task execution
   - Manages conversation history
   - Coordinates API requests
   - Manages file operations and tool usage

3. **MCP Hub (src/services/mcp/McpHub.ts)**
   - Manages Model Context Protocol servers
   - Handles server connections and lifecycle
   - Coordinates tool execution
   - Manages server configuration

### State Management (Core)

1. **Global State**
   - Stored in VSCode's extension context
   - Persists between sessions
   - Includes:
     - API configuration
     - Custom instructions
     - Task history
     - Settings
     - MCP configuration

2. **Secrets Storage**
   - Secure storage for sensitive data
   - Handles:
     - API keys
     - Authentication tokens
     - Other credentials

3. **Task State**
   - Stored per task in the extension's global storage
   - Includes:
     - Conversation history
     - UI messages
     - Checkpoints
     - File changes

### File Structure

```
src/
├── api/                 # API providers and transformations
├── core/               # Core extension logic
├── integrations/       # VSCode integration points
├── services/          # Shared services
└── shared/            # Shared types and utilities
```

## Webview Architecture

### Key Components

1. **ExtensionStateContext (webview-ui/src/context/ExtensionStateContext.tsx)**
   - Central state management for webview
   - Handles communication with extension
   - Manages UI state and updates

2. **React Components**
   - Located in webview-ui/src/components
   - Modular design for reusability
   - Follows React best practices

### State Management (Webview)

1. **Extension State Context**
   - Manages bidirectional communication with extension
   - Handles state synchronization
   - Provides state access to components

2. **Local Component State**
   - Used for UI-specific state
   - Managed through React hooks
   - Ephemeral state not requiring persistence

### File Structure

```
webview-ui/
├── src/
│   ├── components/    # React components
│   ├── context/      # State management
│   └── utils/        # Utility functions
└── public/           # Static assets
```

## Provider System

### API Providers

Located in src/api/providers/, each provider implements:
- Authentication
- Request handling
- Response transformation
- Error handling

Supported providers include:
- Anthropic
- OpenAI
- OpenRouter
- AWS Bedrock
- Google Vertex
- Local models (Ollama, LM Studio)

### Provider Configuration

1. **Configuration Storage**
   - API keys stored in secrets
   - Provider settings in global state
   - Model configurations

2. **Provider Selection**
   - Dynamic provider switching
   - Model selection
   - Configuration validation

## MCP (Model Context Protocol) Integration

### Server Management

1. **Configuration**
   - Stored in cline_mcp_settings.json
   - Includes:
     - Server commands
     - Environment variables
     - Auto-approval settings

2. **Server Lifecycle**
   - Automatic startup
   - Health monitoring
   - Error handling
   - Graceful shutdown

### Tool Integration

1. **Tool Registration**
   - Dynamic tool discovery
   - Schema validation
   - Capability advertising

2. **Tool Execution**
   - Request validation
   - Error handling
   - Result transformation

## Authentication & User Management

### Firebase Integration

1. **FirebaseAuthManager**
   - Handles user authentication
   - Manages login/logout flows
   - Stores user information
   - Coordinates with Cline backend

2. **Token Management**
   - Secure token storage
   - Token refresh handling
   - Session management
   - Auth state synchronization

### User Data

1. **Profile Information**
   - Display name
   - Email
   - Profile picture
   - Account settings

2. **Preferences Storage**
   - User settings
   - Custom configurations
   - Theme preferences
   - Tool auto-approvals

## Browser Integration

### Puppeteer Implementation

1. **Browser Session Management**
   - Launch/close browser instances
   - Handle navigation
   - Manage page state
   - Coordinate screenshots

2. **Interaction Capabilities**
   - Click handling
   - Form input
   - Scrolling
   - Navigation
   - Screenshot capture

### Browser Settings

1. **Configuration Options**
   - Window size
   - Default timeout
   - Navigation settings
   - Screenshot preferences

2. **State Management**
   - Browser instance tracking
   - Page state monitoring
   - Error handling
   - Resource cleanup

## Terminal Integration

### TerminalManager

1. **Command Execution**
   - Process spawning
   - Output capture
   - Error handling
   - Environment management

2. **Terminal Instance Management**
   - Create/dispose terminals
   - Handle multiple instances
   - Track active processes
   - Manage environment variables

### Command Handling

1. **Execution Flow**
   - Command validation
   - Environment setup
   - Process monitoring
   - Output processing

2. **Security Considerations**
   - Command sanitization
   - Permission checking
   - Resource limitations
   - Error boundaries

## Diagnostic System

### Debug Capabilities

1. **Logging System**
   - Error tracking
   - Performance monitoring
   - State changes
   - API interactions

2. **Diagnostic Tools**
   - Stack trace analysis
   - Memory usage monitoring
   - Performance profiling
   - Network debugging

### Error Handling

1. **Error Types**
   - API errors
   - File system errors
   - Network errors
   - State management errors

2. **Recovery Strategies**
   - Automatic retry
   - Graceful degradation
   - State recovery
   - User notification

## Checkpoint System

### Implementation

1. **Checkpoint Creation**
   - State snapshots
   - File system state
   - Conversation history
   - Tool execution state

2. **Restoration Process**
   - State verification
   - File system recovery
   - History reconstruction
   - Tool state recovery

### Management

1. **Storage**
   - Checkpoint organization
   - Cleanup policies
   - Space management
   - Metadata tracking

2. **Operations**
   - Create checkpoints
   - Restore from checkpoint
   - Delete checkpoints
   - Compare checkpoints

## Best Practices

### Core Extension Development

1. **State Management**
   - Use appropriate storage for different types of data
   - Implement proper error handling
   - Maintain state consistency
   - Clear state cleanup

2. **File Operations**
   - Use proper error handling
   - Implement atomic operations
   - Maintain backups for critical operations
   - Handle concurrent access

3. **API Integration**
   - Implement proper rate limiting
   - Handle authentication securely
   - Transform responses consistently
   - Implement retry logic

### Webview Development

1. **Component Design**
   - Follow React best practices
   - Implement proper prop typing
   - Use hooks effectively
   - Maintain component isolation

2. **State Management**
   - Use context appropriately
   - Implement proper state updates
   - Handle side effects correctly
   - Maintain state consistency

3. **Performance**
   - Implement proper memoization
   - Optimize re-renders
   - Handle large datasets efficiently
   - Implement proper cleanup

### MCP Development

1. **Server Implementation**
   - Follow MCP protocol specification
   - Implement proper error handling
   - Maintain server stability
   - Handle resource cleanup

2. **Tool Development**
   - Implement clear schemas
   - Handle errors gracefully
   - Provide clear documentation
   - Maintain backward compatibility

## Libraries & Dependencies

### Core Extension
- VSCode Extension API
- TypeScript
- Axios for HTTP requests
- fs/promises for file operations
- Various API client libraries

### Webview
- React
- TypeScript
- react-use for hooks
- Various UI components

## Additional File Summaries

### Integration Files

1. **src/integrations/terminal/TerminalManager.ts**
   - Terminal instance management
   - Command execution
   - Output handling
   - Environment control

2. **src/integrations/browser/BrowserManager.ts**
   - Puppeteer integration
   - Browser session control
   - Page interaction
   - Screenshot management

3. **src/integrations/diagnostics/DiagnosticManager.ts**
   - Error tracking
   - Performance monitoring
   - Debug logging
   - System health checks

4. **src/integrations/checkpoints/CheckpointManager.ts**
   - Checkpoint creation
   - State restoration
   - File system snapshots
   - History management

### Service Files

1. **src/services/auth/FirebaseAuthManager.ts**
   - User authentication
   - Token management
   - Session control
   - Profile management

2. **src/services/logging/LogManager.ts**
   - Log collection
   - Error reporting
   - Performance tracking
   - Debug information

3. **src/services/browser/BrowserService.ts**
   - Browser automation
   - Page manipulation
   - DOM interaction
   - Resource management

### Utility Files

1. **src/utils/fs.ts**
   - File system operations
   - Path management
   - Directory handling
   - File manipulation

2. **src/utils/shell.ts**
   - Shell command execution
   - Environment management
   - Process control
   - Output parsing

3. **src/utils/string.ts**
   - String manipulation
   - Text processing
   - Pattern matching
   - Format conversion

## File Summaries

### Core Extension Files

1. **src/extension.ts**
   - Extension entry point
   - Registers commands
   - Initializes providers

2. **src/core/Cline.ts**
   - Main business logic
   - Task management
   - Tool coordination

3. **src/core/webview/ClineProvider.ts**
   - Webview management
   - State persistence
   - Message handling

4. **src/api/index.ts**
   - API coordination
   - Provider management
   - Request handling

5. **src/services/mcp/McpHub.ts**
   - MCP server management
   - Tool coordination
   - Configuration handling

### Webview Files

1. **webview-ui/src/App.tsx**
   - Main React component
   - Route management
   - Layout structure

2. **webview-ui/src/context/ExtensionStateContext.tsx**
   - State management
   - Extension communication
   - Context provider

3. **webview-ui/src/components/**
   - Reusable UI components
   - Feature-specific components
   - Layout components

## Package Management

### Separate Node Modules

1. **Core Extension Dependencies**
   - Located in root `/node_modules`
   - Managed by root `package.json`
   - Contains VSCode API dependencies
   - Includes extension-specific packages
   - Install using `npm install` from root

2. **Webview Dependencies**
   - Located in `webview-ui/node_modules`
   - Managed by `webview-ui/package.json`
   - Contains React and UI dependencies
   - Includes webview-specific packages
   - Install using `cd webview-ui && npm install`

3. **Best Practices**
   - Always verify correct directory before installing
   - Keep dependencies isolated between core and webview
   - Avoid duplicate dependencies
   - Use appropriate package.json for each context

## Webview-Extension Communication

### Message System

1. **Message Types**
   ```typescript
   // In shared/WebviewMessage.ts
   interface WebviewMessage {
     type: "newTask" | "apiConfiguration" | "customInstructions" | /* other types */
     text?: string
     images?: string[]
     // Other type-specific properties
   }

   // In shared/ExtensionMessage.ts
   interface ExtensionMessage {
     type: "state" | "theme" | "workspaceUpdated" | /* other types */
     state?: ExtensionState
     text?: string
     // Other type-specific properties
   }
   ```

2. **Sending Messages from Webview**
   ```typescript
   // In webview component
   const handleAction = () => {
     vscode.postMessage({
       type: "newTask",
       text: "Task description"
     })
   }
   ```

3. **Handling Messages in Extension**
   ```typescript
   // In ClineProvider.ts
   private setWebviewMessageListener(webview: vscode.Webview) {
     webview.onDidReceiveMessage(async (message: WebviewMessage) => {
       switch (message.type) {
         case "newTask":
           await this.initClineWithTask(message.text, message.images)
           break
         // Other message handlers
       }
     })
   }
   ```

4. **Sending Messages from Extension**
   ```typescript
   // In ClineProvider.ts
   async postMessageToWebview(message: ExtensionMessage) {
     await this.view?.webview.postMessage(message)
   }
   ```

### Complex Webview Features

1. **Dynamic Component Loading**
   ```typescript
   // In webview-ui/src/components/DynamicComponent.tsx
   const DynamicComponent: React.FC<Props> = ({ type, data }) => {
     const [component, setComponent] = useState<JSX.Element | null>(null)

     useEffect(() => {
       const loadComponent = async () => {
         switch (type) {
           case "settings":
             const Settings = (await import("./Settings")).default
             setComponent(<Settings data={data} />)
             break
           // Other dynamic components
         }
       }
       loadComponent()
     }, [type, data])

     return component
   }
   ```

2. **Advanced State Updates**
   ```typescript
   // In ExtensionStateContext.tsx
   const handleStateUpdate = useCallback((newState: Partial<ExtensionState>) => {
     setState(prevState => {
       const updatedState = { ...prevState, ...newState }
       // Validate state consistency
       if (updatedState.apiConfiguration?.apiProvider !== prevState.apiConfiguration?.apiProvider) {
         // Handle provider change side effects
       }
       return updatedState
     })
   }, [])
   ```

3. **Complex UI Interactions**
   ```typescript
   // Example of a complex settings component
   const AdvancedSettingsPanel: React.FC = () => {
     const { state, updateSettings } = useExtensionState()
     const [localState, setLocalState] = useState(state.settings)
     
     const handleComplexUpdate = async (value: any) => {
       // Validate
       const isValid = await validateSetting(value)
       if (!isValid) return
       
       // Update local state
       setLocalState(prev => ({
         ...prev,
         [value.key]: value.data
       }))
       
       // Sync with extension
       updateSettings({
         type: "complexUpdate",
         data: value
       })
     }
     
     return (/* UI implementation */)
   }
   ```

## MCP Integration and Tool Usage

### MCP Tool Implementation

1. **Tool Registration**
   ```typescript
   // In MCP server implementation
   server.setRequestHandler(ListToolsRequestSchema, async () => ({
     tools: [{
       name: "example_tool",
       description: "Tool description",
       inputSchema: {
         type: "object",
         properties: {
           param1: { type: "string" },
           param2: { type: "number" }
         },
         required: ["param1"]
       }
     }]
   }))
   ```

2. **Tool Execution**
   ```typescript
   server.setRequestHandler(CallToolRequestSchema, async (request) => {
     if (request.params.name === "example_tool") {
       try {
         const result = await executeToolLogic(request.params.arguments)
         return {
           content: [{
             type: "text",
             text: JSON.stringify(result)
           }]
         }
       } catch (error) {
         return {
           content: [{
             type: "text",
             text: `Error: ${error.message}`
           }],
           isError: true
         }
       }
     }
   })
   ```

### Tool Usage in Extension

1. **Tool Coordination**
   ```typescript
   // In Cline.ts
   async executeTool(toolName: string, params: any) {
     const mcpHub = await this.getMcpHub()
     const result = await mcpHub.executeTool(toolName, params)
     
     // Handle result
     if (result.isError) {
       await this.handleToolError(result)
     } else {
       await this.processToolResult(result)
     }
   }
   ```

2. **Tool Auto-Approval**
   ```typescript
   // In ClineProvider.ts
   shouldAutoApproveTool(toolName: string): boolean {
     const settings = this.autoApprovalSettings
     return settings.approvedTools.includes(toolName) ||
            settings.autoApproveAll
   }
   ```

## System Prompt Management

### Important Notes

1. **System Prompt Location**
   - The system prompt is embedded in the extension's core
   - Located in the compiled extension code
   - Not meant to be directly edited
   - Changes require extension updates

2. **Modifying System Behavior**
   - Do not edit system prompt directly
   - Instead, use custom instructions feature
   - Suggest changes through chat interface
   - Document proposed changes for review

3. **Custom Instructions**
   - Use custom instructions for behavioral changes
   - Maintain in extension settings
   - Persist across sessions
   - Override default behaviors safely

### Best Practices

1. **Suggesting Changes**
   ```typescript
   // Example of proper custom instruction addition
   const suggestSystemPromptChange = async (suggestion: string) => {
     await vscode.window.showInformationMessage(
       `Suggested system prompt change: ${suggestion}\n` +
       `Please use custom instructions or report an issue.`
     )
   }
   ```

2. **Custom Instruction Management**
   ```typescript
   // In settings management
   const updateCustomInstructions = async (instructions: string) => {
     await this.updateGlobalState("customInstructions", instructions)
     if (this.cline) {
       this.cline.customInstructions = instructions
     }
   }
   ```

## Webview State Management

### Extension State Context

1. **Core Implementation**
   ```typescript
   interface ExtensionStateContextType extends ExtensionState {
     didHydrateState: boolean
     showWelcome: boolean
     theme: any
     openRouterModels: Record<string, ModelInfo>
     // Add new state properties here
   }
   ```

2. **State Updates**
   - Use setState for synchronous updates
   - Handle async updates through message system
   - Maintain type safety with interfaces
   - Coordinate with extension through postMessage

3. **Adding New State**
   - Define types in shared interfaces
   - Add to ExtensionStateContextType
   - Update initial state in provider
   - Add corresponding message handlers
   - Implement state setters

### Settings Management

1. **Settings Architecture**
   - Settings stored in extension context
   - Synced with webview through messages
   - Persisted across sessions
   - Type-safe through interfaces

2. **Adding New Settings**
   ```typescript
   // 1. Define types in shared/
   interface NewSettingType {
     property: string
     enabled: boolean
   }

   // 2. Add to extension state
   interface ExtensionState {
     newSetting: NewSettingType
   }

   // 3. Add default values
   const DEFAULT_NEW_SETTING: NewSettingType = {
     property: "",
     enabled: false
   }

   // 4. Implement in ExtensionStateContext
   const [newSetting, setNewSetting] = useState(DEFAULT_NEW_SETTING)
   ```

3. **Settings Persistence**
   - Use extension's global state
   - Implement update methods
   - Handle serialization
   - Manage default values

### Advanced Settings

1. **Implementation Pattern**
   ```typescript
   // Define advanced setting interface
   interface AdvancedSetting<T> {
     value: T
     isAdvanced: boolean
     validation?: (value: T) => boolean
   }

   // Create setting with metadata
   const setting: AdvancedSetting<string> = {
     value: "default",
     isAdvanced: true,
     validation: (value) => value.length > 0
   }
   ```

2. **UI Integration**
   - Conditional rendering based on mode
   - Advanced toggle controls
   - Validation feedback
   - Help text and documentation

3. **State Management**
   - Track advanced mode state
   - Persist user preferences
   - Handle validation
   - Manage dependencies

4. **Adding New Advanced Settings**
   - Define in shared interfaces
   - Implement validation
   - Add to state management
   - Create UI components
   - Handle persistence

## Development Workflow

1. **Setting Up Development Environment**
   - Clone repository
   - Install dependencies
   - Configure VSCode settings
   - Set up test environment

2. **Making Changes**
   - Follow TypeScript best practices
   - Maintain proper typing
   - Update documentation
   - Add tests as needed

3. **Testing**
   - Run unit tests
   - Perform integration testing
   - Test in VSCode environment
   - Verify MCP functionality

4. **Debugging**
   - Use VSCode debugging tools
   - Check extension logs
   - Monitor state changes
   - Verify tool execution

## Conclusion

This document serves as a comprehensive guide for developing and maintaining the Cline extension. Follow these guidelines to ensure consistent, maintainable, and efficient code. Regular updates to this document are encouraged as the extension evolves.
